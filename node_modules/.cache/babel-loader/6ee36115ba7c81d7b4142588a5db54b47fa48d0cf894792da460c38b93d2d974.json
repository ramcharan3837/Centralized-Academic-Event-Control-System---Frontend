{"ast":null,"code":"import { useLayoutEffect as $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c } from \"./useLayoutEffect.mjs\";\nimport { useState as $fCAlL$useState, useRef as $fCAlL$useRef, useCallback as $fCAlL$useCallback } from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $1dbecbe27a04f9af$export$14d238f342723f25(defaultValue) {\n  let [value, setValue] = (0, $fCAlL$useState)(defaultValue);\n  // Keep an up to date copy of value in a ref so we can access the current value in the generator.\n  // This allows us to maintain a stable queue function.\n  let currValue = (0, $fCAlL$useRef)(value);\n  let effect = (0, $fCAlL$useRef)(null);\n  // Store the function in a ref so we can always access the current version\n  // which has the proper `value` in scope.\n  let nextRef = (0, $fCAlL$useRef)(() => {\n    if (!effect.current) return;\n    // Run the generator to the next yield.\n    let newValue = effect.current.next();\n    // If the generator is done, reset the effect.\n    if (newValue.done) {\n      effect.current = null;\n      return;\n    }\n    // If the value is the same as the current value,\n    // then continue to the next yield. Otherwise,\n    // set the value in state and wait for the next layout effect.\n    if (currValue.current === newValue.value) nextRef.current();else setValue(newValue.value);\n  });\n  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {\n    currValue.current = value;\n    // If there is an effect currently running, continue to the next yield.\n    if (effect.current) nextRef.current();\n  });\n  let queue = (0, $fCAlL$useCallback)(fn => {\n    effect.current = fn(currValue.current);\n    nextRef.current();\n  }, [nextRef]);\n  return [value, queue];\n}\nexport { $1dbecbe27a04f9af$export$14d238f342723f25 as useValueEffect };","map":{"version":3,"names":["$1dbecbe27a04f9af$export$14d238f342723f25","defaultValue","value","setValue","$fCAlL$useState","currValue","$fCAlL$useRef","effect","nextRef","current","newValue","next","done","$f0a04ccd8dbdd83b$export$e5c5a5f917a5871c","queue","$fCAlL$useCallback","fn"],"sources":["C:\\Users\\ASUS\\Downloads\\event-frontend (3) (1) (1)\\event-frontend (2) (1)\\event-frontend\\event-frontend\\node_modules\\@react-aria\\utils\\dist\\packages\\@react-aria\\utils\\src\\useValueEffect.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Dispatch, RefObject, useCallback, useRef, useState} from 'react';\nimport {useLayoutEffect} from './';\n\ntype SetValueAction<S> = (prev: S) => Generator<any, void, unknown>;\n\n// This hook works like `useState`, but when setting the value, you pass a generator function\n// that can yield multiple values. Each yielded value updates the state and waits for the next\n// layout effect, then continues the generator. This allows sequential updates to state to be\n// written linearly.\nexport function useValueEffect<S>(defaultValue: S | (() => S)): [S, Dispatch<SetValueAction<S>>] {\n  let [value, setValue] = useState(defaultValue);\n  // Keep an up to date copy of value in a ref so we can access the current value in the generator.\n  // This allows us to maintain a stable queue function.\n  let currValue = useRef(value);\n  let effect: RefObject<Generator<S> | null> = useRef<Generator<S> | null>(null);\n\n  // Store the function in a ref so we can always access the current version\n  // which has the proper `value` in scope.\n  let nextRef = useRef(() => {\n    if (!effect.current) {\n      return;\n    }\n    // Run the generator to the next yield.\n    let newValue = effect.current.next();\n\n    // If the generator is done, reset the effect.\n    if (newValue.done) {\n      effect.current = null;\n      return;\n    }\n\n    // If the value is the same as the current value,\n    // then continue to the next yield. Otherwise,\n    // set the value in state and wait for the next layout effect.\n    if (currValue.current === newValue.value) {\n      nextRef.current();\n    } else {\n      setValue(newValue.value);\n    }\n  });\n\n  useLayoutEffect(() => {\n    currValue.current = value;\n    // If there is an effect currently running, continue to the next yield.\n    if (effect.current) {\n      nextRef.current();\n    }\n  });\n\n  let queue = useCallback(fn => {\n    effect.current = fn(currValue.current);\n    nextRef.current();\n  }, [nextRef]);\n\n  return [value, queue];\n}\n"],"mappings":";;;AAAA;;;;;;;;;;;;AAqBO,SAASA,0CAAkBC,YAA2B;EAC3D,IAAI,CAACC,KAAA,EAAOC,QAAA,CAAS,GAAG,IAAAC,eAAO,EAAEH,YAAA;EACjC;EACA;EACA,IAAII,SAAA,GAAY,IAAAC,aAAK,EAAEJ,KAAA;EACvB,IAAIK,MAAA,GAAyC,IAAAD,aAAK,EAAuB;EAEzE;EACA;EACA,IAAIE,OAAA,GAAU,IAAAF,aAAK,EAAE;IACnB,IAAI,CAACC,MAAA,CAAOE,OAAO,EACjB;IAEF;IACA,IAAIC,QAAA,GAAWH,MAAA,CAAOE,OAAO,CAACE,IAAI;IAElC;IACA,IAAID,QAAA,CAASE,IAAI,EAAE;MACjBL,MAAA,CAAOE,OAAO,GAAG;MACjB;IACF;IAEA;IACA;IACA;IACA,IAAIJ,SAAA,CAAUI,OAAO,KAAKC,QAAA,CAASR,KAAK,EACtCM,OAAA,CAAQC,OAAO,QAEfN,QAAA,CAASO,QAAA,CAASR,KAAK;EAE3B;EAEA,IAAAW,yCAAc,EAAE;IACdR,SAAA,CAAUI,OAAO,GAAGP,KAAA;IACpB;IACA,IAAIK,MAAA,CAAOE,OAAO,EAChBD,OAAA,CAAQC,OAAO;EAEnB;EAEA,IAAIK,KAAA,GAAQ,IAAAC,kBAAU,EAAEC,EAAA;IACtBT,MAAA,CAAOE,OAAO,GAAGO,EAAA,CAAGX,SAAA,CAAUI,OAAO;IACrCD,OAAA,CAAQC,OAAO;EACjB,GAAG,CAACD,OAAA,CAAQ;EAEZ,OAAO,CAACN,KAAA,EAAOY,KAAA,CAAM;AACvB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}