{"ast":null,"code":"import { ignoreFocusEvent as $8a9cb279dc87e130$export$fda7da73ab5d4c48 } from \"./utils.mjs\";\nimport { isMac as $28AnR$isMac, openLink as $28AnR$openLink, isVirtualClick as $28AnR$isVirtualClick, getOwnerWindow as $28AnR$getOwnerWindow, getOwnerDocument as $28AnR$getOwnerDocument } from \"@react-aria/utils\";\nimport { useState as $28AnR$useState, useEffect as $28AnR$useEffect } from \"react\";\nimport { useIsSSR as $28AnR$useIsSSR } from \"@react-aria/ssr\";\n\n/*\r\n * Copyright 2020 Adobe. All rights reserved.\r\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License. You may obtain a copy\r\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software distributed under\r\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\r\n * OF ANY KIND, either express or implied. See the License for the specific language\r\n * governing permissions and limitations under the License.\r\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\nlet $507fabe10e71c6fb$var$currentModality = null;\nlet $507fabe10e71c6fb$var$currentPointerType = 'keyboard';\nlet $507fabe10e71c6fb$var$changeHandlers = new Set();\nlet $507fabe10e71c6fb$export$d90243b58daecda7 = new Map(); // We use a map here to support setting event listeners across multiple document objects.\nlet $507fabe10e71c6fb$var$hasEventBeforeFocus = false;\nlet $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;\n// Only Tab or Esc keys will make focus visible on text input elements\nconst $507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS = {\n  Tab: true,\n  Escape: true\n};\nfunction $507fabe10e71c6fb$var$triggerChangeHandlers(modality, e) {\n  for (let handler of $507fabe10e71c6fb$var$changeHandlers) handler(modality, e);\n}\n/**\r\n * Helper function to determine if a KeyboardEvent is unmodified and could make keyboard focus styles visible.\r\n */\nfunction $507fabe10e71c6fb$var$isValidKey(e) {\n  // Control and Shift keys trigger when navigating back to the tab with keyboard.\n  return !(e.metaKey || !(0, $28AnR$isMac)() && e.altKey || e.ctrlKey || e.key === 'Control' || e.key === 'Shift' || e.key === 'Meta');\n}\nfunction $507fabe10e71c6fb$var$handleKeyboardEvent(e) {\n  $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n  if (!(0, $28AnR$openLink).isOpening && $507fabe10e71c6fb$var$isValidKey(e)) {\n    $507fabe10e71c6fb$var$currentModality = 'keyboard';\n    $507fabe10e71c6fb$var$currentPointerType = 'keyboard';\n    $507fabe10e71c6fb$var$triggerChangeHandlers('keyboard', e);\n  }\n}\nfunction $507fabe10e71c6fb$var$handlePointerEvent(e) {\n  $507fabe10e71c6fb$var$currentModality = 'pointer';\n  $507fabe10e71c6fb$var$currentPointerType = 'pointerType' in e ? e.pointerType : 'mouse';\n  if (e.type === 'mousedown' || e.type === 'pointerdown') {\n    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n    $507fabe10e71c6fb$var$triggerChangeHandlers('pointer', e);\n  }\n}\nfunction $507fabe10e71c6fb$var$handleClickEvent(e) {\n  if (!(0, $28AnR$openLink).isOpening && (0, $28AnR$isVirtualClick)(e)) {\n    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n    $507fabe10e71c6fb$var$currentModality = 'virtual';\n    $507fabe10e71c6fb$var$currentPointerType = 'virtual';\n  }\n}\nfunction $507fabe10e71c6fb$var$handleFocusEvent(e) {\n  // Firefox fires two extra focus events when the user first clicks into an iframe:\n  // first on the window, then on the document. We ignore these events so they don't\n  // cause keyboard focus rings to appear.\n  if (e.target === window || e.target === document || (0, $8a9cb279dc87e130$export$fda7da73ab5d4c48) || !e.isTrusted) return;\n  // If a focus event occurs without a preceding keyboard or pointer event, switch to virtual modality.\n  // This occurs, for example, when navigating a form with the next/previous buttons on iOS.\n  if (!$507fabe10e71c6fb$var$hasEventBeforeFocus && !$507fabe10e71c6fb$var$hasBlurredWindowRecently) {\n    $507fabe10e71c6fb$var$currentModality = 'virtual';\n    $507fabe10e71c6fb$var$currentPointerType = 'virtual';\n    $507fabe10e71c6fb$var$triggerChangeHandlers('virtual', e);\n  }\n  $507fabe10e71c6fb$var$hasEventBeforeFocus = false;\n  $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;\n}\nfunction $507fabe10e71c6fb$var$handleWindowBlur() {\n  if (0, $8a9cb279dc87e130$export$fda7da73ab5d4c48) return;\n  // When the window is blurred, reset state. This is necessary when tabbing out of the window,\n  // for example, since a subsequent focus event won't be fired.\n  $507fabe10e71c6fb$var$hasEventBeforeFocus = false;\n  $507fabe10e71c6fb$var$hasBlurredWindowRecently = true;\n}\n/**\r\n * Setup global event listeners to control when keyboard focus style should be visible.\r\n */\nfunction $507fabe10e71c6fb$var$setupGlobalFocusEvents(element) {\n  if (typeof window === 'undefined' || typeof document === 'undefined' || $507fabe10e71c6fb$export$d90243b58daecda7.get((0, $28AnR$getOwnerWindow)(element))) return;\n  const windowObject = (0, $28AnR$getOwnerWindow)(element);\n  const documentObject = (0, $28AnR$getOwnerDocument)(element);\n  // Programmatic focus() calls shouldn't affect the current input modality.\n  // However, we need to detect other cases when a focus event occurs without\n  // a preceding user event (e.g. screen reader focus). Overriding the focus\n  // method on HTMLElement.prototype is a bit hacky, but works.\n  let focus = windowObject.HTMLElement.prototype.focus;\n  windowObject.HTMLElement.prototype.focus = function () {\n    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n    focus.apply(this, arguments);\n  };\n  documentObject.addEventListener('keydown', $507fabe10e71c6fb$var$handleKeyboardEvent, true);\n  documentObject.addEventListener('keyup', $507fabe10e71c6fb$var$handleKeyboardEvent, true);\n  documentObject.addEventListener('click', $507fabe10e71c6fb$var$handleClickEvent, true);\n  // Register focus events on the window so they are sure to happen\n  // before React's event listeners (registered on the document).\n  windowObject.addEventListener('focus', $507fabe10e71c6fb$var$handleFocusEvent, true);\n  windowObject.addEventListener('blur', $507fabe10e71c6fb$var$handleWindowBlur, false);\n  if (typeof PointerEvent !== 'undefined') {\n    documentObject.addEventListener('pointerdown', $507fabe10e71c6fb$var$handlePointerEvent, true);\n    documentObject.addEventListener('pointermove', $507fabe10e71c6fb$var$handlePointerEvent, true);\n    documentObject.addEventListener('pointerup', $507fabe10e71c6fb$var$handlePointerEvent, true);\n  } else if (process.env.NODE_ENV === 'test') {\n    documentObject.addEventListener('mousedown', $507fabe10e71c6fb$var$handlePointerEvent, true);\n    documentObject.addEventListener('mousemove', $507fabe10e71c6fb$var$handlePointerEvent, true);\n    documentObject.addEventListener('mouseup', $507fabe10e71c6fb$var$handlePointerEvent, true);\n  }\n  // Add unmount handler\n  windowObject.addEventListener('beforeunload', () => {\n    $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element);\n  }, {\n    once: true\n  });\n  $507fabe10e71c6fb$export$d90243b58daecda7.set(windowObject, {\n    focus: focus\n  });\n}\nconst $507fabe10e71c6fb$var$tearDownWindowFocusTracking = (element, loadListener) => {\n  const windowObject = (0, $28AnR$getOwnerWindow)(element);\n  const documentObject = (0, $28AnR$getOwnerDocument)(element);\n  if (loadListener) documentObject.removeEventListener('DOMContentLoaded', loadListener);\n  if (!$507fabe10e71c6fb$export$d90243b58daecda7.has(windowObject)) return;\n  windowObject.HTMLElement.prototype.focus = $507fabe10e71c6fb$export$d90243b58daecda7.get(windowObject).focus;\n  documentObject.removeEventListener('keydown', $507fabe10e71c6fb$var$handleKeyboardEvent, true);\n  documentObject.removeEventListener('keyup', $507fabe10e71c6fb$var$handleKeyboardEvent, true);\n  documentObject.removeEventListener('click', $507fabe10e71c6fb$var$handleClickEvent, true);\n  windowObject.removeEventListener('focus', $507fabe10e71c6fb$var$handleFocusEvent, true);\n  windowObject.removeEventListener('blur', $507fabe10e71c6fb$var$handleWindowBlur, false);\n  if (typeof PointerEvent !== 'undefined') {\n    documentObject.removeEventListener('pointerdown', $507fabe10e71c6fb$var$handlePointerEvent, true);\n    documentObject.removeEventListener('pointermove', $507fabe10e71c6fb$var$handlePointerEvent, true);\n    documentObject.removeEventListener('pointerup', $507fabe10e71c6fb$var$handlePointerEvent, true);\n  } else if (process.env.NODE_ENV === 'test') {\n    documentObject.removeEventListener('mousedown', $507fabe10e71c6fb$var$handlePointerEvent, true);\n    documentObject.removeEventListener('mousemove', $507fabe10e71c6fb$var$handlePointerEvent, true);\n    documentObject.removeEventListener('mouseup', $507fabe10e71c6fb$var$handlePointerEvent, true);\n  }\n  $507fabe10e71c6fb$export$d90243b58daecda7.delete(windowObject);\n};\nfunction $507fabe10e71c6fb$export$2f1888112f558a7d(element) {\n  const documentObject = (0, $28AnR$getOwnerDocument)(element);\n  let loadListener;\n  if (documentObject.readyState !== 'loading') $507fabe10e71c6fb$var$setupGlobalFocusEvents(element);else {\n    loadListener = () => {\n      $507fabe10e71c6fb$var$setupGlobalFocusEvents(element);\n    };\n    documentObject.addEventListener('DOMContentLoaded', loadListener);\n  }\n  return () => $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element, loadListener);\n}\n// Server-side rendering does not have the document object defined\n// eslint-disable-next-line no-restricted-globals\nif (typeof document !== 'undefined') $507fabe10e71c6fb$export$2f1888112f558a7d();\nfunction $507fabe10e71c6fb$export$b9b3dfddab17db27() {\n  return $507fabe10e71c6fb$var$currentModality !== 'pointer';\n}\nfunction $507fabe10e71c6fb$export$630ff653c5ada6a9() {\n  return $507fabe10e71c6fb$var$currentModality;\n}\nfunction $507fabe10e71c6fb$export$8397ddfc504fdb9a(modality) {\n  $507fabe10e71c6fb$var$currentModality = modality;\n  $507fabe10e71c6fb$var$currentPointerType = modality === 'pointer' ? 'mouse' : modality;\n  $507fabe10e71c6fb$var$triggerChangeHandlers(modality, null);\n}\nfunction $507fabe10e71c6fb$export$887a228355cf7d95() {\n  return $507fabe10e71c6fb$var$currentPointerType;\n}\nfunction $507fabe10e71c6fb$export$98e20ec92f614cfe() {\n  $507fabe10e71c6fb$var$setupGlobalFocusEvents();\n  let [modality, setModality] = (0, $28AnR$useState)($507fabe10e71c6fb$var$currentModality);\n  (0, $28AnR$useEffect)(() => {\n    let handler = () => {\n      setModality($507fabe10e71c6fb$var$currentModality);\n    };\n    $507fabe10e71c6fb$var$changeHandlers.add(handler);\n    return () => {\n      $507fabe10e71c6fb$var$changeHandlers.delete(handler);\n    };\n  }, []);\n  return (0, $28AnR$useIsSSR)() ? null : modality;\n}\nconst $507fabe10e71c6fb$var$nonTextInputTypes = new Set(['checkbox', 'radio', 'range', 'color', 'file', 'image', 'button', 'submit', 'reset']);\n/**\r\n * If this is attached to text input component, return if the event is a focus event (Tab/Escape keys pressed) so that\r\n * focus visible style can be properly set.\r\n */\nfunction $507fabe10e71c6fb$var$isKeyboardFocusEvent(isTextInput, modality, e) {\n  let document1 = (0, $28AnR$getOwnerDocument)(e === null || e === void 0 ? void 0 : e.target);\n  const IHTMLInputElement = typeof window !== 'undefined' ? (0, $28AnR$getOwnerWindow)(e === null || e === void 0 ? void 0 : e.target).HTMLInputElement : HTMLInputElement;\n  const IHTMLTextAreaElement = typeof window !== 'undefined' ? (0, $28AnR$getOwnerWindow)(e === null || e === void 0 ? void 0 : e.target).HTMLTextAreaElement : HTMLTextAreaElement;\n  const IHTMLElement = typeof window !== 'undefined' ? (0, $28AnR$getOwnerWindow)(e === null || e === void 0 ? void 0 : e.target).HTMLElement : HTMLElement;\n  const IKeyboardEvent = typeof window !== 'undefined' ? (0, $28AnR$getOwnerWindow)(e === null || e === void 0 ? void 0 : e.target).KeyboardEvent : KeyboardEvent;\n  // For keyboard events that occur on a non-input element that will move focus into input element (aka ArrowLeft going from Datepicker button to the main input group)\n  // we need to rely on the user passing isTextInput into here. This way we can skip toggling focus visiblity for said input element\n  isTextInput = isTextInput || document1.activeElement instanceof IHTMLInputElement && !$507fabe10e71c6fb$var$nonTextInputTypes.has(document1.activeElement.type) || document1.activeElement instanceof IHTMLTextAreaElement || document1.activeElement instanceof IHTMLElement && document1.activeElement.isContentEditable;\n  return !(isTextInput && modality === 'keyboard' && e instanceof IKeyboardEvent && !$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS[e.key]);\n}\nfunction $507fabe10e71c6fb$export$ffd9e5021c1fb2d6(props = {}) {\n  let {\n    isTextInput: isTextInput,\n    autoFocus: autoFocus\n  } = props;\n  let [isFocusVisibleState, setFocusVisible] = (0, $28AnR$useState)(autoFocus || $507fabe10e71c6fb$export$b9b3dfddab17db27());\n  $507fabe10e71c6fb$export$ec71b4b83ac08ec3(isFocusVisible => {\n    setFocusVisible(isFocusVisible);\n  }, [isTextInput], {\n    isTextInput: isTextInput\n  });\n  return {\n    isFocusVisible: isFocusVisibleState\n  };\n}\nfunction $507fabe10e71c6fb$export$ec71b4b83ac08ec3(fn, deps, opts) {\n  $507fabe10e71c6fb$var$setupGlobalFocusEvents();\n  (0, $28AnR$useEffect)(() => {\n    let handler = (modality, e) => {\n      // We want to early return for any keyboard events that occur inside text inputs EXCEPT for Tab and Escape\n      if (!$507fabe10e71c6fb$var$isKeyboardFocusEvent(!!(opts === null || opts === void 0 ? void 0 : opts.isTextInput), modality, e)) return;\n      fn($507fabe10e71c6fb$export$b9b3dfddab17db27());\n    };\n    $507fabe10e71c6fb$var$changeHandlers.add(handler);\n    return () => {\n      $507fabe10e71c6fb$var$changeHandlers.delete(handler);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps);\n}\nexport { $507fabe10e71c6fb$export$d90243b58daecda7 as hasSetupGlobalListeners, $507fabe10e71c6fb$export$2f1888112f558a7d as addWindowFocusTracking, $507fabe10e71c6fb$export$b9b3dfddab17db27 as isFocusVisible, $507fabe10e71c6fb$export$630ff653c5ada6a9 as getInteractionModality, $507fabe10e71c6fb$export$8397ddfc504fdb9a as setInteractionModality, $507fabe10e71c6fb$export$887a228355cf7d95 as getPointerType, $507fabe10e71c6fb$export$98e20ec92f614cfe as useInteractionModality, $507fabe10e71c6fb$export$ffd9e5021c1fb2d6 as useFocusVisible, $507fabe10e71c6fb$export$ec71b4b83ac08ec3 as useFocusVisibleListener };","map":{"version":3,"names":["$507fabe10e71c6fb$var$currentModality","$507fabe10e71c6fb$var$currentPointerType","$507fabe10e71c6fb$var$changeHandlers","Set","$507fabe10e71c6fb$export$d90243b58daecda7","Map","$507fabe10e71c6fb$var$hasEventBeforeFocus","$507fabe10e71c6fb$var$hasBlurredWindowRecently","$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS","Tab","Escape","$507fabe10e71c6fb$var$triggerChangeHandlers","modality","e","handler","$507fabe10e71c6fb$var$isValidKey","metaKey","$28AnR$isMac","altKey","ctrlKey","key","$507fabe10e71c6fb$var$handleKeyboardEvent","$28AnR$openLink","isOpening","$507fabe10e71c6fb$var$handlePointerEvent","pointerType","type","$507fabe10e71c6fb$var$handleClickEvent","$28AnR$isVirtualClick","$507fabe10e71c6fb$var$handleFocusEvent","target","window","document","$8a9cb279dc87e130$export$fda7da73ab5d4c48","isTrusted","$507fabe10e71c6fb$var$handleWindowBlur","$507fabe10e71c6fb$var$setupGlobalFocusEvents","element","get","$28AnR$getOwnerWindow","windowObject","documentObject","$28AnR$getOwnerDocument","focus","HTMLElement","prototype","apply","arguments","addEventListener","PointerEvent","process","env","NODE_ENV","$507fabe10e71c6fb$var$tearDownWindowFocusTracking","once","set","loadListener","removeEventListener","has","delete","$507fabe10e71c6fb$export$2f1888112f558a7d","readyState","$507fabe10e71c6fb$export$b9b3dfddab17db27","$507fabe10e71c6fb$export$630ff653c5ada6a9","$507fabe10e71c6fb$export$8397ddfc504fdb9a","$507fabe10e71c6fb$export$887a228355cf7d95","$507fabe10e71c6fb$export$98e20ec92f614cfe","setModality","$28AnR$useState","$28AnR$useEffect","add","$28AnR$useIsSSR","$507fabe10e71c6fb$var$nonTextInputTypes","$507fabe10e71c6fb$var$isKeyboardFocusEvent","isTextInput","document1","IHTMLInputElement","HTMLInputElement","IHTMLTextAreaElement","HTMLTextAreaElement","IHTMLElement","IKeyboardEvent","KeyboardEvent","activeElement","isContentEditable","$507fabe10e71c6fb$export$ffd9e5021c1fb2d6","props","autoFocus","isFocusVisibleState","setFocusVisible","$507fabe10e71c6fb$export$ec71b4b83ac08ec3","isFocusVisible","fn","deps","opts"],"sources":["C:\\Users\\ASUS\\Downloads\\event-frontend (3) (1) (1)\\event-frontend (2) (1)\\event-frontend\\event-frontend\\node_modules\\@react-aria\\interactions\\dist\\packages\\@react-aria\\interactions\\src\\useFocusVisible.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\nimport {getOwnerDocument, getOwnerWindow, isMac, isVirtualClick, openLink} from '@react-aria/utils';\nimport {ignoreFocusEvent} from './utils';\nimport {PointerType} from '@react-types/shared';\nimport {useEffect, useState} from 'react';\nimport {useIsSSR} from '@react-aria/ssr';\n\nexport type Modality = 'keyboard' | 'pointer' | 'virtual';\ntype HandlerEvent = PointerEvent | MouseEvent | KeyboardEvent | FocusEvent | null;\ntype Handler = (modality: Modality, e: HandlerEvent) => void;\nexport type FocusVisibleHandler = (isFocusVisible: boolean) => void;\nexport interface FocusVisibleProps {\n  /** Whether the element is a text input. */\n  isTextInput?: boolean,\n  /** Whether the element will be auto focused. */\n  autoFocus?: boolean\n}\n\nexport interface FocusVisibleResult {\n  /** Whether keyboard focus is visible globally. */\n  isFocusVisible: boolean\n}\n\nlet currentModality: null | Modality = null;\nlet currentPointerType: PointerType = 'keyboard';\nlet changeHandlers = new Set<Handler>();\ninterface GlobalListenerData {\n  focus: () => void\n}\nexport let hasSetupGlobalListeners: Map<Window, GlobalListenerData> = new Map<Window, GlobalListenerData>(); // We use a map here to support setting event listeners across multiple document objects.\nlet hasEventBeforeFocus = false;\nlet hasBlurredWindowRecently = false;\n\n// Only Tab or Esc keys will make focus visible on text input elements\nconst FOCUS_VISIBLE_INPUT_KEYS = {\n  Tab: true,\n  Escape: true\n};\n\nfunction triggerChangeHandlers(modality: Modality, e: HandlerEvent) {\n  for (let handler of changeHandlers) {\n    handler(modality, e);\n  }\n}\n\n/**\n * Helper function to determine if a KeyboardEvent is unmodified and could make keyboard focus styles visible.\n */\nfunction isValidKey(e: KeyboardEvent) {\n  // Control and Shift keys trigger when navigating back to the tab with keyboard.\n  return !(e.metaKey || (!isMac() && e.altKey) || e.ctrlKey || e.key === 'Control' || e.key === 'Shift' || e.key === 'Meta');\n}\n\n\nfunction handleKeyboardEvent(e: KeyboardEvent) {\n  hasEventBeforeFocus = true;\n  if (!(openLink as any).isOpening && isValidKey(e)) {\n    currentModality = 'keyboard';\n    currentPointerType = 'keyboard';\n    triggerChangeHandlers('keyboard', e);\n  }\n}\n\nfunction handlePointerEvent(e: PointerEvent | MouseEvent) {\n  currentModality = 'pointer';\n  currentPointerType = 'pointerType' in e ? e.pointerType as PointerType : 'mouse';\n  if (e.type === 'mousedown' || e.type === 'pointerdown') {\n    hasEventBeforeFocus = true;\n    triggerChangeHandlers('pointer', e);\n  }\n}\n\nfunction handleClickEvent(e: MouseEvent) {\n  if (!(openLink as any).isOpening && isVirtualClick(e)) {\n    hasEventBeforeFocus = true;\n    currentModality = 'virtual';\n    currentPointerType = 'virtual';\n  }\n}\n\nfunction handleFocusEvent(e: FocusEvent) {\n  // Firefox fires two extra focus events when the user first clicks into an iframe:\n  // first on the window, then on the document. We ignore these events so they don't\n  // cause keyboard focus rings to appear.\n  if (e.target === window || e.target === document || ignoreFocusEvent || !e.isTrusted) {\n    return;\n  }\n\n  // If a focus event occurs without a preceding keyboard or pointer event, switch to virtual modality.\n  // This occurs, for example, when navigating a form with the next/previous buttons on iOS.\n  if (!hasEventBeforeFocus && !hasBlurredWindowRecently) {\n    currentModality = 'virtual';\n    currentPointerType = 'virtual';\n    triggerChangeHandlers('virtual', e);\n  }\n\n  hasEventBeforeFocus = false;\n  hasBlurredWindowRecently = false;\n}\n\nfunction handleWindowBlur() {\n  if (ignoreFocusEvent) {\n    return;\n  }\n\n  // When the window is blurred, reset state. This is necessary when tabbing out of the window,\n  // for example, since a subsequent focus event won't be fired.\n  hasEventBeforeFocus = false;\n  hasBlurredWindowRecently = true;\n}\n\n/**\n * Setup global event listeners to control when keyboard focus style should be visible.\n */\nfunction setupGlobalFocusEvents(element?: HTMLElement | null) {\n  if (typeof window === 'undefined' || typeof document === 'undefined' || hasSetupGlobalListeners.get(getOwnerWindow(element))) {\n    return;\n  }\n\n  const windowObject = getOwnerWindow(element);\n  const documentObject = getOwnerDocument(element);\n\n  // Programmatic focus() calls shouldn't affect the current input modality.\n  // However, we need to detect other cases when a focus event occurs without\n  // a preceding user event (e.g. screen reader focus). Overriding the focus\n  // method on HTMLElement.prototype is a bit hacky, but works.\n  let focus = windowObject.HTMLElement.prototype.focus;\n  windowObject.HTMLElement.prototype.focus = function () {\n    hasEventBeforeFocus = true;\n    focus.apply(this, arguments as unknown as [options?: FocusOptions | undefined]);\n  };\n\n  documentObject.addEventListener('keydown', handleKeyboardEvent, true);\n  documentObject.addEventListener('keyup', handleKeyboardEvent, true);\n  documentObject.addEventListener('click', handleClickEvent, true);\n\n  // Register focus events on the window so they are sure to happen\n  // before React's event listeners (registered on the document).\n  windowObject.addEventListener('focus', handleFocusEvent, true);\n  windowObject.addEventListener('blur', handleWindowBlur, false);\n\n  if (typeof PointerEvent !== 'undefined') {\n    documentObject.addEventListener('pointerdown', handlePointerEvent, true);\n    documentObject.addEventListener('pointermove', handlePointerEvent, true);\n    documentObject.addEventListener('pointerup', handlePointerEvent, true);\n  } else if (process.env.NODE_ENV === 'test') {\n    documentObject.addEventListener('mousedown', handlePointerEvent, true);\n    documentObject.addEventListener('mousemove', handlePointerEvent, true);\n    documentObject.addEventListener('mouseup', handlePointerEvent, true);\n  }\n\n  // Add unmount handler\n  windowObject.addEventListener('beforeunload', () => {\n    tearDownWindowFocusTracking(element);\n  }, {once: true});\n\n  hasSetupGlobalListeners.set(windowObject, {focus});\n}\n\nconst tearDownWindowFocusTracking = (element, loadListener?: () => void) => {\n  const windowObject = getOwnerWindow(element);\n  const documentObject = getOwnerDocument(element);\n  if (loadListener) {\n    documentObject.removeEventListener('DOMContentLoaded', loadListener);\n  }\n  if (!hasSetupGlobalListeners.has(windowObject)) {\n    return;\n  }\n  windowObject.HTMLElement.prototype.focus = hasSetupGlobalListeners.get(windowObject)!.focus;\n\n  documentObject.removeEventListener('keydown', handleKeyboardEvent, true);\n  documentObject.removeEventListener('keyup', handleKeyboardEvent, true);\n  documentObject.removeEventListener('click', handleClickEvent, true);\n\n  windowObject.removeEventListener('focus', handleFocusEvent, true);\n  windowObject.removeEventListener('blur', handleWindowBlur, false);\n\n  if (typeof PointerEvent !== 'undefined') {\n    documentObject.removeEventListener('pointerdown', handlePointerEvent, true);\n    documentObject.removeEventListener('pointermove', handlePointerEvent, true);\n    documentObject.removeEventListener('pointerup', handlePointerEvent, true);\n  } else if (process.env.NODE_ENV === 'test') {\n    documentObject.removeEventListener('mousedown', handlePointerEvent, true);\n    documentObject.removeEventListener('mousemove', handlePointerEvent, true);\n    documentObject.removeEventListener('mouseup', handlePointerEvent, true);\n  }\n\n  hasSetupGlobalListeners.delete(windowObject);\n};\n\n/**\n * EXPERIMENTAL\n * Adds a window (i.e. iframe) to the list of windows that are being tracked for focus visible.\n *\n * Sometimes apps render portions of their tree into an iframe. In this case, we cannot accurately track if the focus\n * is visible because we cannot see interactions inside the iframe. If you have this in your application's architecture,\n * then this function will attach event listeners inside the iframe. You should call `addWindowFocusTracking` with an\n * element from inside the window you wish to add. We'll retrieve the relevant elements based on that.\n * Note, you do not need to call this for the default window, as we call it for you.\n *\n * When you are ready to stop listening, but you do not wish to unmount the iframe, you may call the cleanup function\n * returned by `addWindowFocusTracking`. Otherwise, when you unmount the iframe, all listeners and state will be cleaned\n * up automatically for you.\n *\n * @param element @default document.body - The element provided will be used to get the window to add.\n * @returns A function to remove the event listeners and cleanup the state.\n */\nexport function addWindowFocusTracking(element?: HTMLElement | null): () => void {\n  const documentObject = getOwnerDocument(element);\n  let loadListener;\n  if (documentObject.readyState !== 'loading') {\n    setupGlobalFocusEvents(element);\n  } else {\n    loadListener = () => {\n      setupGlobalFocusEvents(element);\n    };\n    documentObject.addEventListener('DOMContentLoaded', loadListener);\n  }\n\n  return () => tearDownWindowFocusTracking(element, loadListener);\n}\n\n// Server-side rendering does not have the document object defined\n// eslint-disable-next-line no-restricted-globals\nif (typeof document !== 'undefined') {\n  addWindowFocusTracking();\n}\n\n/**\n * If true, keyboard focus is visible.\n */\nexport function isFocusVisible(): boolean {\n  return currentModality !== 'pointer';\n}\n\nexport function getInteractionModality(): Modality | null {\n  return currentModality;\n}\n\nexport function setInteractionModality(modality: Modality): void {\n  currentModality = modality;\n  currentPointerType = modality === 'pointer' ? 'mouse' : modality;\n  triggerChangeHandlers(modality, null);\n}\n\n/** @private */\nexport function getPointerType(): PointerType {\n  return currentPointerType;\n}\n\n/**\n * Keeps state of the current modality.\n */\nexport function useInteractionModality(): Modality | null {\n  setupGlobalFocusEvents();\n\n  let [modality, setModality] = useState(currentModality);\n  useEffect(() => {\n    let handler = () => {\n      setModality(currentModality);\n    };\n\n    changeHandlers.add(handler);\n    return () => {\n      changeHandlers.delete(handler);\n    };\n  }, []);\n\n  return useIsSSR() ? null : modality;\n}\n\nconst nonTextInputTypes = new Set([\n  'checkbox',\n  'radio',\n  'range',\n  'color',\n  'file',\n  'image',\n  'button',\n  'submit',\n  'reset'\n]);\n\n/**\n * If this is attached to text input component, return if the event is a focus event (Tab/Escape keys pressed) so that\n * focus visible style can be properly set.\n */\nfunction isKeyboardFocusEvent(isTextInput: boolean, modality: Modality, e: HandlerEvent) {\n  let document = getOwnerDocument(e?.target as Element);\n  const IHTMLInputElement = typeof window !== 'undefined' ? getOwnerWindow(e?.target as Element).HTMLInputElement : HTMLInputElement;\n  const IHTMLTextAreaElement = typeof window !== 'undefined' ? getOwnerWindow(e?.target as Element).HTMLTextAreaElement : HTMLTextAreaElement;\n  const IHTMLElement = typeof window !== 'undefined' ? getOwnerWindow(e?.target as Element).HTMLElement : HTMLElement;\n  const IKeyboardEvent = typeof window !== 'undefined' ? getOwnerWindow(e?.target as Element).KeyboardEvent : KeyboardEvent;\n\n  // For keyboard events that occur on a non-input element that will move focus into input element (aka ArrowLeft going from Datepicker button to the main input group)\n  // we need to rely on the user passing isTextInput into here. This way we can skip toggling focus visiblity for said input element\n  isTextInput = isTextInput ||\n    (document.activeElement instanceof IHTMLInputElement && !nonTextInputTypes.has(document.activeElement.type)) ||\n    document.activeElement instanceof IHTMLTextAreaElement ||\n    (document.activeElement instanceof IHTMLElement && document.activeElement.isContentEditable);\n  return !(isTextInput && modality === 'keyboard' && e instanceof IKeyboardEvent && !FOCUS_VISIBLE_INPUT_KEYS[e.key]);\n}\n\n/**\n * Manages focus visible state for the page, and subscribes individual components for updates.\n */\nexport function useFocusVisible(props: FocusVisibleProps = {}): FocusVisibleResult {\n  let {isTextInput, autoFocus} = props;\n  let [isFocusVisibleState, setFocusVisible] = useState(autoFocus || isFocusVisible());\n  useFocusVisibleListener((isFocusVisible) => {\n    setFocusVisible(isFocusVisible);\n  }, [isTextInput], {isTextInput});\n\n  return {isFocusVisible: isFocusVisibleState};\n}\n\n/**\n * Listens for trigger change and reports if focus is visible (i.e., modality is not pointer).\n */\nexport function useFocusVisibleListener(fn: FocusVisibleHandler, deps: ReadonlyArray<any>, opts?: {isTextInput?: boolean}): void {\n  setupGlobalFocusEvents();\n\n  useEffect(() => {\n    let handler = (modality: Modality, e: HandlerEvent) => {\n      // We want to early return for any keyboard events that occur inside text inputs EXCEPT for Tab and Escape\n      if (!isKeyboardFocusEvent(!!(opts?.isTextInput), modality, e)) {\n        return;\n      }\n      fn(isFocusVisible());\n    };\n    changeHandlers.add(handler);\n    return () => {\n      changeHandlers.delete(handler);\n    };\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}