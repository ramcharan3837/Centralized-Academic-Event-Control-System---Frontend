{"ast":null,"code":"function memo(getDeps, fn, opts) {\n  let deps = opts.initialDeps ?? [];\n  let result;\n  let isInitial = true;\n  function memoizedFunction() {\n    var _a, _b, _c;\n    let depTime;\n    if (opts.key && ((_a = opts.debug) == null ? void 0 : _a.call(opts))) depTime = Date.now();\n    const newDeps = getDeps();\n    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);\n    if (!depsChanged) {\n      return result;\n    }\n    deps = newDeps;\n    let resultTime;\n    if (opts.key && ((_b = opts.debug) == null ? void 0 : _b.call(opts))) resultTime = Date.now();\n    result = fn(...newDeps);\n    if (opts.key && ((_c = opts.debug) == null ? void 0 : _c.call(opts))) {\n      const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n      const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n      const resultFpsPercentage = resultEndTime / 16;\n      const pad = (str, num) => {\n        str = String(str);\n        while (str.length < num) {\n          str = \" \" + str;\n        }\n        return str;\n      };\n      console.info(`%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? void 0 : opts.key);\n    }\n    if ((opts == null ? void 0 : opts.onChange) && !(isInitial && opts.skipInitialOnChange)) {\n      opts.onChange(result);\n    }\n    isInitial = false;\n    return result;\n  }\n  memoizedFunction.updateDeps = newDeps => {\n    deps = newDeps;\n  };\n  return memoizedFunction;\n}\nfunction notUndefined(value, msg) {\n  if (value === void 0) {\n    throw new Error(`Unexpected undefined${msg ? `: ${msg}` : \"\"}`);\n  } else {\n    return value;\n  }\n}\nconst approxEqual = (a, b) => Math.abs(a - b) < 1.01;\nconst debounce = (targetWindow, fn, ms) => {\n  let timeoutId;\n  return function (...args) {\n    targetWindow.clearTimeout(timeoutId);\n    timeoutId = targetWindow.setTimeout(() => fn.apply(this, args), ms);\n  };\n};\nexport { approxEqual, debounce, memo, notUndefined };","map":{"version":3,"names":["memo","getDeps","fn","opts","deps","initialDeps","result","isInitial","memoizedFunction","_a","_b","_c","depTime","key","debug","call","Date","now","newDeps","depsChanged","length","some","dep","index","resultTime","depEndTime","Math","round","resultEndTime","resultFpsPercentage","pad","str","num","String","console","info","max","min","onChange","skipInitialOnChange","updateDeps","notUndefined","value","msg","Error","approxEqual","a","b","abs","debounce","targetWindow","ms","timeoutId","args","clearTimeout","setTimeout","apply"],"sources":["C:\\Users\\ASUS\\Downloads\\event-frontend (3) (1) (1)\\event-frontend (2) (1)\\event-frontend\\event-frontend\\node_modules\\@tanstack\\virtual-core\\src\\utils.ts"],"sourcesContent":["export type NoInfer<A extends any> = [A][A extends any ? 0 : never]\n\nexport type PartialKeys<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>\n\nexport function memo<TDeps extends ReadonlyArray<any>, TResult>(\n  getDeps: () => [...TDeps],\n  fn: (...args: NoInfer<[...TDeps]>) => TResult,\n  opts: {\n    key: false | string\n    debug?: () => boolean\n    onChange?: (result: TResult) => void\n    initialDeps?: TDeps\n    skipInitialOnChange?: boolean\n  },\n) {\n  let deps = opts.initialDeps ?? []\n  let result: TResult | undefined\n  let isInitial = true\n\n  function memoizedFunction(): TResult {\n    let depTime: number\n    if (opts.key && opts.debug?.()) depTime = Date.now()\n\n    const newDeps = getDeps()\n\n    const depsChanged =\n      newDeps.length !== deps.length ||\n      newDeps.some((dep: any, index: number) => deps[index] !== dep)\n\n    if (!depsChanged) {\n      return result!\n    }\n\n    deps = newDeps\n\n    let resultTime: number\n    if (opts.key && opts.debug?.()) resultTime = Date.now()\n\n    result = fn(...newDeps)\n\n    if (opts.key && opts.debug?.()) {\n      const depEndTime = Math.round((Date.now() - depTime!) * 100) / 100\n      const resultEndTime = Math.round((Date.now() - resultTime!) * 100) / 100\n      const resultFpsPercentage = resultEndTime / 16\n\n      const pad = (str: number | string, num: number) => {\n        str = String(str)\n        while (str.length < num) {\n          str = ' ' + str\n        }\n        return str\n      }\n\n      console.info(\n        `%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,\n        `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(\n              0,\n              Math.min(120 - 120 * resultFpsPercentage, 120),\n            )}deg 100% 31%);`,\n        opts?.key,\n      )\n    }\n\n    if (opts?.onChange && !(isInitial && opts.skipInitialOnChange)) {\n      opts.onChange(result)\n    }\n\n    isInitial = false\n\n    return result\n  }\n\n  // Attach updateDeps to the function itself\n  memoizedFunction.updateDeps = (newDeps: [...TDeps]) => {\n    deps = newDeps\n  }\n\n  return memoizedFunction\n}\n\nexport function notUndefined<T>(value: T | undefined, msg?: string): T {\n  if (value === undefined) {\n    throw new Error(`Unexpected undefined${msg ? `: ${msg}` : ''}`)\n  } else {\n    return value\n  }\n}\n\nexport const approxEqual = (a: number, b: number) => Math.abs(a - b) < 1.01\n\nexport const debounce = (\n  targetWindow: Window & typeof globalThis,\n  fn: Function,\n  ms: number,\n) => {\n  let timeoutId: number\n  return function (this: any, ...args: Array<any>) {\n    targetWindow.clearTimeout(timeoutId)\n    timeoutId = targetWindow.setTimeout(() => fn.apply(this, args), ms)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}